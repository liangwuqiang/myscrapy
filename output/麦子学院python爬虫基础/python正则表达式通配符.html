<!DOCTYPE html>
        <html><head><meta charset="UTF-8">
        </head><body>
        <p><center><h1>python正则表达式通配符</h1></center></p>
            <div class="cont">
<h1>python正则表达式通配符</h1>
<p><p><br/></p><hr/><h3><span style="color: rgb(94, 207, 186);">dot</span></h3><p><br/></p><p>示例：</p><p><br/></p><p># -*- coding: utf-8 -*-</p><p><br/></p><p>import re</p><p><br/></p><p>def re_pattern_syntax():</p><p>    # dot</p><p>    print(re.match(r'.*', 'abc\nedf').group())  //.可以匹配任意的字符，*这个字符可以任意的0到多个</p><p>   </p><p>if __name__ == '__main__':</p><p>re_pattern_syntax()</p><p><br/></p><p>运行结果，匹配abc，为什么它没有匹配这个\n呢？因为\n是换行符，也就是说，这个字符串实际上是分成两行的，所以正则表达式是一行一行的去匹配，如果有换行符我就认为这个字符串就结束了，所以它不会去匹配下一行的内容。</p><p><br/></p><p><img alt="grammar1.png" src="images/52a362dd5a49c35c8407da6a540efadf.png" title="UJsUmjcpXH6RCAQF6r.png"/></p><p><br/></p><p>除非我们这样，修改代码：</p><p><br/></p><p># -*- coding: utf-8 -*-</p><p>import re</p><p><br/></p><p>def re_pattern_syntax():</p><p>    # dot</p><p>    print(re.match(r'.*', 'abc\nedf',re.DOTALL).group())  //DOTALL表示，我这个.不单单表示任意的字符串，它还可以表示这个换行符   </p><p>if __name__ == '__main__':</p><p>re_pattern_syntax()</p><p><br/></p><p>运行结果，这样他就可以把整个字符串都匹配下来了。</p><p><br/></p><p><img alt="grammar2.png" src="images/ed3069163316090ed73a4cc081378c50.png" title="8sOC0HP3ST4g77Zkzl.png"/></p><p><br/></p><hr/><h3><span style="color: rgb(94, 207, 186);">caret</span></h3><p><strong><br/></strong></p><p># -*- coding: utf-8 -*-</p><p>import re</p><p><br/></p><p>def re_pattern_syntax():</p><p>    # caret</p><p>    print(re.findall(r'^abc', 'abc\nabc'))   //findall找出所有的</p><p> </p><p>if __name__ == '__main__':</p><p>re_pattern_syntax()</p><p><br/></p><p>运行结果，虽然这里面包含了换行符，它算作两行，但是在我们实际匹配的时候，是会把它当做整个字符串去匹配，所以值匹配了开始位置，\nabc表示新行，所以它返回的只有abc。</p><p><br/></p><p><img alt="grammar3.png" src="images/2cba50e95144eaf44b9987e662ebd31d.png" title="udeGuPDgdPeY3MrdWP.png"/></p><p><br/></p><p># -*- coding: utf-8 -*-</p><p>import re</p><p><br/></p><p>def re_pattern_syntax():</p><p>    # caret</p><p>print(re.findall(r'^abc', 'abc\nabc', re.MULTILINE))  //MULTILINE把这个字符串当做多行去处理，那这个时候，^就不单单表示字符串的开始了，就表示一个行的开始，abc表示一个行，\nabc表示另一个新行</p><p> </p><p>if __name__ == '__main__':</p><p>re_pattern_syntax()</p><p><br/></p><p>运行结果，所以这个caret是对这个通配符是有影响的。</p><p><br/></p><p><img alt="grammar4.png" src="images/75013ccfbf6014729889a3112c9eefc5.png" title="E2b20Cg0M0PxNriv1B.png"/></p><p><br/></p><hr/><h3><span style="color: rgb(94, 207, 186);">$：（和^相反，^表示开始，$表示结束）</span></h3><p><br/></p><p># -*- coding: utf-8 -*-</p><p>import re</p><p><br/></p><p>def re_pattern_syntax():</p><p> # $</p><p> print(re.findall(r'abc\d$', 'abc1\nabc2'))   //一个字符串以abc和一个数字结尾的</p><p> </p><p>if __name__ == '__main__':</p><p>re_pattern_syntax()</p><p><br/></p><p>运行结果，为什么它没有匹配到abc1而是匹配到了abc2呢？因为在不加任何frag的情况下，这个美元符号所表示的是一个字符串的结束，而不是行的结束，所以是abc2。</p><p><br/></p><p><img alt="grammar5.png" src="images/d633429f39bd820c1f92ee2dc7fc7c4d.png" title="bLAqE8a2a44wpEFC4d.png"/></p><p><br/></p><p>如果，我们修改一下代码，看看结果与什么变化：</p><p><br/></p><p># -*- coding: utf-8 -*-</p><p>import re</p><p><br/></p><p>def re_pattern_syntax():</p><p> # $</p><p> print(re.findall(r'abc\d$', 'abc1\nabc2', re.MULTILINE))</p><p> </p><p>if __name__ == '__main__':</p><p>re_pattern_syntax()</p><p><br/></p><p>运行结果，大家可以看到，加了MULTILINE之后，就表示告诉这个函数说，这个字符串，我要把它当作多行来处理，也就是每一行匹配一次，那这样呢它就会匹配abc1和abc2，因为它是多行的。</p><p><br/></p><p><img alt="grammar6.png" src="images/edc17c4d4b4e5aea37c1e9077ee23d9a.png" title="QFJFquFcg8m9zaJNEt.png"/></p><p><br/></p><hr/><h3><span style="color: rgb(94, 207, 186);">*/+/?</span></h3><p><br/></p><p>它们分别表示前一个匹配单元的匹配次数，*表示匹配0到多个，+表示匹配1到多个，最小是一个，?表示匹配0个或1个，页就是要么有要么没有</p><p><br/></p><p># -*- coding: utf-8 -*-</p><p>import re</p><p><br/></p><p>def re_pattern_syntax():</p><p># *</p><p>print(re.match(r'ab*', 'a'))   //匹配一个a，b可以匹配0到多个，也就是没有b也可以</p><p>   </p><p>if __name__ == '__main__':</p><p>re_pattern_syntax()</p><p><br/></p><p>运行结果，返回是Match Object也就是我的返回是有值的。</p><p><br/></p><p><img alt="grammar7.png" src="images/60243e71fe64e5a56b6fb89f37c8003b.png" title="ntWcVoWgrT5XoIv0t7.png"/></p><p><br/></p><p>如果我这里是两个b呢？</p><p><br/></p><p># -*- coding: utf-8 -*-</p><p>import re</p><p><br/></p><p>def re_pattern_syntax():</p><p>    # *</p><p>print(re.match(r'ab*', 'abb'))   //匹配一个a，b可以匹配0到多个，也就是没有b也可以</p><p>   </p><p>if __name__ == '__main__':</p><p>re_pattern_syntax()</p><p><br/></p><p>运行结果，输出没有变化。</p><p><br/></p><p><img alt="grammar8.png" src="images/3752f1050baba4424557d73ac7f5b54d.png" title="I0QKVg86wFg9AiY6lF.png"/></p><p><br/></p><p>那如果我输出一个c呢？</p><p><br/></p><p># -*- coding: utf-8 -*-</p><p>import re</p><p><br/></p><p>def re_pattern_syntax():</p><p>    # *</p><p>print(re.match(r'ab*', 'ac'))   //匹配一个a，b可以匹配0到多个，也就是没有b也可以</p><p>   </p><p>if __name__ == '__main__':</p><p>re_pattern_syntax()</p><p><br/></p><p>运行结果，它也是可以的，因为b是可选的，所以即使a和c没有包含b也是可以的</p><p><br/></p><p><img alt="grammar9.png" src="images/ed84561f443290316b005db1288fd6b7.png" title="gNITlU8gNSfF4TdDTc.png"/></p><p><br/></p><p>我们来看另外一个</p><p><br/></p><p># -*- coding: utf-8 -*-</p><p>import re</p><p><br/></p><p>def re_pattern_syntax():</p><p>    # +</p><p>print(re.match(r'ab+', 'a'))    //我匹配a同时要匹配1或多个b</p><p>   </p><p>if __name__ == '__main__':</p><p>re_pattern_syntax()</p><p><br/></p><p>运行结果，返回的是None，也就是没有匹配上。</p><p><br/></p><p><img alt="grammar10.png" src="images/8af3c6079cb14e0434f1d33fa2c6a357.png" title="lTkNenrDjTut7p6QXk.png"/></p><p><br/></p><p>修改代码：</p><p><br/></p><p># -*- coding: utf-8 -*-</p><p>import re</p><p><br/></p><p>def re_pattern_syntax():</p><p>    # +</p><p>print(re.match(r'ab+', 'abb'))    //我匹配a同时要匹配1或多个b</p><p>   </p><p>if __name__ == '__main__':</p><p>re_pattern_syntax()</p><p><br/></p><p>运行结果，匹配成功。</p><p><br/></p><p><img alt="grammar11.png" src="images/346eb45edbc1c3bc03bfaff933e6998f.png" title="q2rpMtoKoTzlJ5pAoJ.png"/></p><p><br/></p><p>那如果我匹配个c呢？</p><p><br/></p><p># -*- coding: utf-8 -*-</p><p>import re</p><p>def re_pattern_syntax():</p><p>    # +</p><p>print(re.match(r'ab+', 'ac))    //我匹配a同时要匹配1或多个b</p><p>   </p><p>if __name__ == '__main__':</p><p>re_pattern_syntax()</p><p><br/></p><p>运行结果，也是不行的，因为a后面至少跟着一个或者多个b。</p><p><br/></p><p><img alt="grammar12.png" src="images/ee75355f2e53dbf6183f5bc5b224da64.png" title="AmH00qgN1aHaHMzSuW.png"/></p><p><br/></p><p>0个b:</p><p><br/></p><p># -*- coding: utf-8 -*-</p><p>import re</p><p><br/></p><p>def re_pattern_syntax():</p><p>    # ?</p><p>    print(re.match(r'ab?', 'a'))</p><p>   </p><p>if __name__ == '__main__':</p><p>re_pattern_syntax()</p><p><br/></p><p>运行结果，这样是可以的，因为它匹配0或者1个b。</p><p><br/></p><p><img alt="grammar13.png" src="images/a6f7fe16a224541b7e6dbc95a13143aa.png" title="XBksMWAM8k3L7WIB1G.png"/></p><p><br/></p><p>1个b:</p><p><br/></p><p># -*- coding: utf-8 -*-</p><p>import re</p><p><br/></p><p>def re_pattern_syntax():</p><p>    # ?</p><p>    print(re.match(r'ab?', 'ab'))</p><p>   </p><p>if __name__ == '__main__':</p><p>re_pattern_syntax()</p><p><br/></p><p>运行结果，匹配成功。</p><p><br/></p><p><img alt="grammar14.png" src="images/c33233c7c434788cc2d19b27bd43f87f.png" title="kf2D4HOr6jzgNuYYfX.png"/></p><p><br/></p><p>2个b:</p><p><br/></p><p># -*- coding: utf-8 -*-</p><p>import re</p><p><br/></p><p>def re_pattern_syntax():</p><p>    # ?</p><p>    print(re.match(r'ab?', 'abb'))</p><p>   </p><p>if __name__ == '__main__':</p><p>re_pattern_syntax()</p><p><br/></p><p>运行结果，一样成功，因为这里的正则表达式是匹配0或1个b，那我这里有2个b，虽然我最多只能匹配1个b，那这样我实际上就是只匹配到第一个b这里就结束了，后面的我们就不管它了，所以这里还是能匹配的上。</p><p><br/></p><p><img alt="grammar15.png" src="images/0497b2fc743b0ca137f47835d197eb5d.png" title="BDVjg4rNPYJI1KQEJb.png"/></p><p><br/></p><p>把这个打印出来：</p><p><br/></p><p># -*- coding: utf-8 -*-</p><p>import re</p><p><br/></p><p>def re_pattern_syntax():</p><p>    # ?</p><p>    print(re.match(r'ab?', 'abb'),group())</p><p>   </p><p>if __name__ == '__main__':</p><p>re_pattern_syntax()</p><p><br/></p><p>运行结果</p><p><br/></p><p><img alt="grammar16.png" src="images/f4b8f177a51e4fcc5fadd17c556b7c2d.png" title="yGvfKy8dKpkV6R3ahd.png"/></p><p><br/></p><p><br/></p><p><span style="color: rgb(192, 0, 0);">【本文由麦子学院独家原创，转载请注明出处并保留原文链接】</span></p><p><br/></p><p>
</p></p></div>
        </body></html>