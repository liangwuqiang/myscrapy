<!DOCTYPE html>
        <html><head><meta charset="UTF-8">
        </head><body>
        <p><center><h1>python爬虫线程实例</h1></center></p>
            <div class="cont">
<h1>python爬虫线程实例</h1>
<p><p><br/></p><hr/><h3><span style="color: rgb(94, 207, 186);">线程的简单例子</span></h3><p><br/></p><p>import threading</p><p>import time</p><p>import random</p><p><br/></p><p>def worker_func():    //线程的工作函数</p><p>    print('worker thread started in %s' % (threading.current_thread()))  //打印出当前线程的名字</p><p>    random.seed()</p><p>    time.sleep(random.random())   //随机的睡眠一段时间，0到1秒不等</p><p>    print('worker thread finished in %s' % (threading.current_thread()))</p><p><br/></p><p>def simple_thread_demo:</p><p>    for i in range(10):   //创建10个线程</p><p>       threading.Thread(target=worker_func)t.start()   //这10个线程同时运行</p><p><br/></p><p>if __name__ == '__main__':</p><p>     simple_thread_demo()</p><p>    </p><p>运行结果，刚开始的时候，这个线程顺序的启动了，然后9先执行完，然后是2，1，所以这个worker_func()，是多个线程同时执行的。</p><p><br/></p><p><img alt="threadeg1.png" src="images/a4f226ec6cc1a6f15bc04527e7a751aa.png" title="lASvqs4xEAQNnwyzsp.png"/></p><p><br/></p><p>那如果我们要保证这个代码一个时间段内只有一个线程在这里面运行，其他的线程必须要在外面等待，那这样的话我们要怎么做呢？</p><p><br/></p><p>代码如下：</p><p><br/></p><p>import threading</p><p>import time</p><p>import random</p><p><br/></p><p>def worker_func():    //线程的工作函数</p><p>    print('worker thread started in %s' % (threading.current_thread()))  //打印出当前线程的名字</p><p>    random.seed()</p><p>    time.sleep(random.random())   //随机的睡眠一段时间，0到1秒不等</p><p>    print('worker thread finished in %s' % (threading.current_thread()))</p><p><br/></p><p>def simple_thread_demo:</p><p>    for i in range(10):   //创建10个线程</p><p>       threading.Thread(target=worker_func)t.start()   //这10个线程同时运行</p><p><br/></p><p>def worker_func_lock(lock):  //传一个锁进来</p><p>    lock.acquire()   //进来的时候要先上锁</p><p>    worker_func()  //调用这个函数</p><p>    lock.release()   //出来的时候把锁给它释放掉</p><p><br/></p><p>gLock = threading.Lock()   //定义一个锁</p><p><br/></p><p>def thread_demo_Lock():</p><p>       for i in range(10):   //创建10个线程</p><p>       threading.Thread(target=worker_func_Lock, args=[gLock]).start()  </p><p><br/></p><p>if __name__ == '__main__':</p><p>     thread_lock_demo()</p><p><br/></p><p>这样就是一个线程安全的代码，也就是说一个时间只会有一个线程来执行这个函数，因为当第一个线程进来的时候，它会去请求这个锁，当第二个线程进来以后，发现这个线程已经被锁住了，它就会再这个线程里面等待，直到第一个线程把给它释放掉以后，第二个锁才会进来去执行这个函数，所以这样就保证了这个函数一个时间段只会有一个线程来执行。</p><p><br/></p><p>运行结果，现在这个线程就变成了顺序执行了，thread 1先去执行，然后它finish执行完后，第二个线程才开始执行，第二个线程执行完后，第三个线程才开始执行。</p><p><br/></p><p><img alt="threadeg2.png" src="images/6993413c9a586aa4eb6b7ced0b312c3c.png" title="B2wlDEo5acSA87Rf3E.png"/></p><p><br/></p><p>我们再来看看信号量：因为这个普通的锁一个时间内只允许一个线程在这个里面运行，那我们信号量就允许多个线程在这个里面工作，我们来看看信号量来怎么做：</p><p><br/></p><p>import threading</p><p>import time</p><p>import random</p><p><br/></p><p>def worker_func():    //线程的工作函数</p><p>    print('worker thread started in %s' % (threading.current_thread()))  //打印出当前线程的名字</p><p>    random.seed()</p><p>    time.sleep(random.random())   //随机的睡眠一段时间，0到1秒不等</p><p>    print('worker thread finished in %s' % (threading.current_thread()))</p><p><br/></p><p>def simple_thread_demo:</p><p>    for i in range(10):   //创建10个线程</p><p>       threading.Thread(target=worker_func)t.start()   //这10个线程同时运行</p><p><br/></p><p>def worker_func_lock(lock):  //传一个锁进来</p><p>    lock.acquire()   //进来的时候要先上锁</p><p>    worker_func()  //调用这个函数</p><p>    lock.release()   //出来的时候把锁给它释放掉</p><p><br/></p><p>gLock = threading.Lock()   //定义一个锁</p><p>gSem= threading.Sem(3)   //假设我们同时运行三个线程在里面执行</p><p><br/></p><p>def thread_demo_Lock():</p><p>       for i in range(10):   //创建10个线程</p><p>       threading.Thread(target=worker_func_Lock, args=[gSem]).start()    //我们再把这个信号量传进来</p><p><br/></p><p>if __name__ == '__main__':</p><p>     thread_lock_demo()</p><p><br/></p><p>运行结果，因为这个信号量允许3个线程同时进行，所以前3个线程就顺利的进入运行了，然后4，5，6，就没办法执行了，只有等到3这个线程完成之后，4才有机会进入这个工作函数执行，然后4完成之后，5才有机会开始执行，所以它保证了这个工作函数同时只能有3个函数在这里同时执行。</p><p><br/></p><p><img alt="threadeg3.png" src="images/a83026157ab6d663b9d5f5126e2957fd.png" title="asktgPqLQrP22LFV9l.png"/></p><p><br/></p><p>接下来我们要介绍的例子是上节课的金库例子，在这个金库里面是典型的生产者和消费者的概念，就是销售它去生产这个金钱，然后它赚了钱会放在这个金库里面，它是个生产者，那采购是消费者，它会从金库里面拿钱去买东西。</p><p><br/></p><p>import threading</p><p>import time</p><p>import random</p><p><br/></p><p>def worker_func():    //线程的工作函数</p><p>    print('worker thread started in %s' % (threading.current_thread()))  //打印出当前线程的名字</p><p>    random.seed()</p><p>    time.sleep(random.random())   //随机的睡眠一段时间，0到1秒不等</p><p>    print('worker thread finished in %s' % (threading.current_thread()))</p><p><br/></p><p>def simple_thread_demo:</p><p>    for i in range(10):   //创建10个线程</p><p>       threading.Thread(target=worker_func)t.start()   //这10个线程同时运行</p><p><br/></p><p>def worker_func_lock(lock):  //传一个锁进来</p><p>    lock.acquire()   //进来的时候要先上锁</p><p>    worker_func()  //调用这个函数</p><p>    lock.release()   //出来的时候把锁给它释放掉</p><p><br/></p><p>gLock = threading.Lock()   //定义一个锁</p><p>gSem= threading.Sem(3)   //假设我们同时运行三个线程在里面执行</p><p><br/></p><p>def thread_demo_Lock():</p><p>       for i in range(10):   //创建10个线程</p><p>       threading.Thread(target=worker_func_Lock, args=[gSem]).start()    //我们再把这个信号量传进来</p><p><br/></p><p>gMoney = 1000  //假设金库原始里面只有1000块钱</p><p>gCondition = threading.Condition()</p><p><br/></p><p>class Producer(threading.Thread):   //构造一个生产者的线程，主要是往金库里面存钱</p><p>    def run(self):   //重写run方法，使生产者变成了主函数</p><p>        print('%s started' % threading.current_thread())</p><p>        while True:</p><p>            global gMoney</p><p>            global gCondition</p><p><br/></p><p>            gCondition.acquire()   //上锁</p><p>            random.seed()</p><p>            p = random.randint(100, 500)  //每次随机往里面放100到500的钱</p><p>            gMoney += p</p><p>            print(Produced %d. Left %d' % ( p, gMoney))  //打印钱数</p><p>            time.sleep(random.random())   //随机的延时，0到1秒</p><p>            gCondition.notify_all()   //通知所有人</p><p>            gCondition.release()   //通知后要释放锁</p><p><br/></p><p><br/></p><p>class Consumer(threading.Thread):  //定义消费者</p><p>    def run(self):    //重写run函数</p><p>        print('%s started' % threading.current_thread())</p><p>        while True:</p><p>            global gMoney</p><p>            global gCondition</p><p><br/></p><p>            gCondition.acquire()   //上锁</p><p>            random.seed()</p><p>            c = random.randint(500, 1000)   //一次随机消费为500到1000</p><p>            print(Trying to consume %d. Left %d' % ( c, gMoney))  //打印钱数，总共多少钱，剩下多少钱</p><p><br/></p><p>            while gMoney &lt; c:   //剩余的钱必须比消费的金额大</p><p>                gCondition.wait()   //不够的话，等必须等生产者放钱</p><p>            gMoney -= c   //消费后扣钱</p><p>            time.sleep(random.random())   //随机的延时，0到1秒</p><p>            print( Consumed %d. Left %d' % ( c, gMoney))</p><p>            gCondition.release()   //把锁释放掉</p><p><br/></p><p>def consumer_producer_demo():   </p><p>    for i in range(1):   //先创建一个</p><p>        Consumer().start()   //创建消费者</p><p><br/></p><p>    for i in range(1):   //先创建一个</p><p>        Producer().start()  //创建生产者</p><p><br/></p><p>if __name__ == '__main__':</p><p>      consumer_producer_demo()</p><p><br/></p><p>运行结果，第一个消费者总共1000，消费了819，钱是够的，所以他消费了819，金库里面只剩下了181，那第二次消费者又准备去消费893，那这个时候，金库里面只剩下了181，这个时候钱不够，所以消费者只能在这里等，接下来生产者出场了，它先生产了494，那这个时候，钱还是不够，所以消费者只能继续在这里等，那第二次生产者生产了222，这个时候，钱变成了897，这个时候钱够了，消费者被唤醒之后，它就会去消费掉893，所以钱值剩下4。</p><p><br/></p><p><img alt="threadeg4.png" src="images/7e182810df4b0c4f6032a9c01fc41cb8.png" title="ZK9897AONKhsH1Gvwe.png"/></p><p><br/></p><p>那我们把这个线程变得更复杂一点，因为我们这里只创建了一个消费者，一个生产者。</p><p>import threading</p><p>import time</p><p>import random</p><p><br/></p><p>def worker_func():    //线程的工作函数</p><p>    print('worker thread started in %s' % (threading.current_thread()))  //打印出当前线程的名字</p><p>    random.seed()</p><p>    time.sleep(random.random())   //随机的睡眠一段时间，0到1秒不等</p><p>    print('worker thread finished in %s' % (threading.current_thread()))</p><p><br/></p><p>def simple_thread_demo:</p><p>    for i in range(10):   //创建10个线程</p><p>       threading.Thread(target=worker_func)t.start()   //这10个线程同时运行</p><p><br/></p><p>def worker_func_lock(lock):  //传一个锁进来</p><p>    lock.acquire()   //进来的时候要先上锁</p><p>    worker_func()  //调用这个函数</p><p>    lock.release()   //出来的时候把锁给它释放掉</p><p><br/></p><p>gLock = threading.Lock()   //定义一个锁</p><p>gSem= threading.Sem(3)   //假设我们同时运行三个线程在里面执行</p><p><br/></p><p>def thread_demo_Lock():</p><p>       for i in range(10):   //创建10个线程</p><p>       threading.Thread(target=worker_func_Lock, args=[gSem]).start()    //我们再把这个信号量传进来</p><p><br/></p><p>gMoney = 1000  //假设金库原始里面只有1000块钱</p><p>gCondition = threading.Condition()</p><p><br/></p><p>class Producer(threading.Thread):   //构造一个生产者的线程，主要是往金库里面存钱</p><p>    def run(self):   //重写run方法，使生产者变成了主函数</p><p>        print('%s started' % threading.current_thread())</p><p>        while True:</p><p>            global gMoney</p><p>            global gCondition</p><p><br/></p><p>            gCondition.acquire()   //上锁</p><p>            random.seed()</p><p>            p = random.randint(500, 1000)  //每次随机往里面放100到500的钱</p><p>            gMoney += p</p><p>            print('%s: Produced %d. Left %d' % (threading.current_thread(), p, gMoney))  //打印钱数</p><p>            time.sleep(random.random())   //随机的延时，0到1秒</p><p>            gCondition.notify_all()   //通知所有人</p><p>            gCondition.release()   //通知后要释放锁</p><p><br/></p><p><br/></p><p>class Consumer(threading.Thread):  //定义消费者</p><p>    def run(self):    //重写run函数</p><p>        print('%s started' % threading.current_thread())</p><p>        while True:</p><p>            global gMoney</p><p>            global gCondition</p><p><br/></p><p>            gCondition.acquire()   //上锁</p><p>            random.seed()</p><p>            c = random.randint(100, 200)   //一次随机消费为500到1000</p><p>            print('%s: Trying to consume %d. Left %d' % (threading.current_thread(), c, gMoney))  //打印钱数，总共多少钱，剩下多少钱，把线程的名称给它打印出来</p><p><br/></p><p>            while gMoney &lt; c:   //剩余的钱必须比消费的金额大</p><p>                gCondition.wait()   //不够的话，等必须等生产者放钱</p><p>            gMoney -= c   //消费后扣钱</p><p>            time.sleep(random.random())   //随机的延时，0到1秒</p><p>            print('%s: Consumed %d. Left %d' % (threading.current_thread(), c, gMoney))</p><p>            gCondition.release()   //把锁释放掉</p><p><br/></p><p>def consumer_producer_demo():   </p><p>    for i in range(10):   //创建10个</p><p>        Consumer().start()   //创建消费者</p><p><br/></p><p>    for i in range(1):   //先创建一个</p><p>        Producer().start()  //创建生产者</p><p><br/></p><p>if __name__ == '__main__':</p><p>      consumer_producer_demo()</p><p><br/></p><p>运行结果，第一个消费者启动以后去消费了118，只剩下了882，接下来其他的消费者都启动了，线程1这个消费者又去消费了170，这个时候只剩下712，第二次又是线程1这个消费者又去消费了188，接下来又是线程1这个消费者又去消费了176，接下来是线程5这个消费者又去消费了129，最终生产者登场，一次性生产了904，金额就变成了961。在这样的模型里面，就可以观察到生产者和消费者可以比较良好的去协同工作，那生产者和消费者这个模型实际上是应用比较广的，我们第一个爬虫去爬取的唐诗三百首的目录的，就是一个生产者，它爬完以后，会把一个个唐诗的url放在这个队列，另一个消费者就会去从这个生产者里面去取出这个url，然后去下载这个唐诗，再把它解析出来。</p><p><br/></p><p><img alt="threadeg5.png" src="images/bcccdf58732de0726f0bd8ead8f394f2.png" title="W29lzoHhrK9rfkqHKc.png"/></p><p><br/></p><hr/><h3><span style="color: rgb(94, 207, 186);">作业：</span></h3><p><br/></p><p>希望大家去阅读一下Python标准库里面的thread这个包</p><p><br/></p><p><br/></p><p><br/></p><p><span style="color: rgb(192, 0, 0);">【本文由麦子学院独家原创，转载请注明出处并保留原文链接】</span></p><p><br/></p><p>
</p></p></div>
        </body></html>