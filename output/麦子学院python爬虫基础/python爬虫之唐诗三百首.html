<!DOCTYPE html>
        <html><head><meta charset="UTF-8">
        </head><body>
        <p><center><h1>python爬虫之唐诗三百首</h1></center></p>
            <div class="cont">
<h1>python爬虫之唐诗三百首</h1>
<p><p><br/></p><hr/><h3><span style="color: rgb(94, 207, 186);">唐诗三百首</span></h3><p><br/></p><p>进入这个网站</p><p><br/></p><p><img alt="practice1.png" src="images/3d9880e6fde467fee966d57c138c6aec.png" title="aZWxEVLEP7COHd91k8.png"/></p><p><br/></p><p><img alt="practice2.png" height="500" src="images/768c33c49ed809689b0d7221436a849e.png" style="width: 715px; height: 500px;" title="f8wEZf1RGRY8CazVTx.png" width="715"/></p><p><br/></p><p>那我们怎么从这个网页里面去把这个古诗三百首的每一首，标题，作者，还有标题网页的url给它爬下来呢？</p><p><br/></p><p>1）爬取诗词标题</p><p><br/></p><p>2）爬取诗词作者</p><p><br/></p><p>3）爬取诗词的网页地址</p><p><br/></p><p>我们需要去分析这个网站的数据结构，我们利用这个开发者工具。</p><p><br/></p><p>我们要爬取的标题和作者都在这个文本里面，我们要爬取的url都在这个href属性里面。</p><p><br/></p><p><img alt="practice3.png" src="images/0362537bcdcc5d4136bb6914442e4d4c.png" title="95RVc5g18jcgDQUbGF.png"/></p><p><br/></p><p>另一方面，我们怎么去匹配我们需要爬取的数据呢？我们可以去观察我们需要匹配的数据的格式，不同的标题的每个div都是不同的。那这些div都有什么特征呢？我们可以看到，每个div后面都有一个class，我们可以利用这个特征，提取出我们需要的数据，还有，我们可以用id来区别也是可以的。</p><p><br/></p><p><img alt="practice4.png" src="images/a9bd8d278135ea4b876f6269f30489de.png" title="ytMG4j1An7D1FVYZva.png"/></p><p><br/></p><p>现在我们使用class来提取，我们感兴趣的是&lt;a&gt; &lt;/a&gt;这个元素，这个a必须在这几个div的下面，在这个div下面的我们才感兴趣，而且这个文本一定要返回这个模式是标题（作者）这个格式，所以，只要满足这个数据格式的，我们就认为它是符合我们的数据要求的。通过这样的分析，我们就可以把这个唐诗三百首去给她爬下来，然后利用正则表达式去解析这个标题，作者，看这个是不是合法的数据，因为最后可能会有不合法的数据。</p><p><br/></p><p><img alt="practice5.png" src="images/808dbd01dfdd8d5776918ed9430ccf4a.png" title="VNf8aXpvymJwSthvuh.png"/></p><p><br/></p><p>比如这个a虽然在这个div下面，但是她的文本是不合法的，它不是标题（作者）的格式。</p><p><br/></p><p><img alt="practice6.png" src="images/0ed66ca1161ea942ce0f8a81b122fbe0.png" title="f1bN1apNrDcunDoLKq.png"/></p><p><br/></p><p>接下来我们看看代码怎么实现：</p><p><br/></p><p># -*- coding: utf-8 -*-</p><p>import requests</p><p>import re</p><p>from HTMLParser import HTMLParser</p><p><br/></p><p><br/></p><p>def _attr(attrs, attrname):   //从属性列表里面去获取指定的值</p><p>    for attr in attrs:</p><p>        if attr[0] == attrname:</p><p>            return attr[1]</p><p>    return None</p><p><br/></p><p>class PoemParser(HTMLParser):</p><p>    def __init__(self):</p><p>        HTMLParser.__init__(self)</p><p>        self.in_div = False   //标志位是不是在这个div下面，默认是False </p><p>        self.in_a = False   //标志进去的是不是在感兴趣的a这个数据下</p><p>         //正则表达式的实例变量，正则表达式：标题部分是任意的字符，但必须有一个括号，compile方法一是为了提高可读性，而是为了提高这个运行的效率，因为handle_data会调用很多次，但实际上我们的正则表达式是一直不变的</p><p>        self.pattern = re.compile(r'''</p><p>(.+)    #匹配标题   group(1)</p><p>\(     #匹配作者左边的括号</p><p>(.+)    #匹配作者   group(2)</p><p>\)      #匹配作者右边的括号</p><p>‘’’,re.VERBOSE) </p><p>        self.tangshi_list = []   //解析出的唐诗三百首数据放在一个数组里</p><p>        self.current_poem = {}   //当前正在解析的唐诗</p><p><br/></p><p>    def handle_starttag(self, tag, attrs):</p><p>        if tag == 'div' and _attr(attrs, 'class') == 'guwencont2':  //需满足条件</p><p>            self.in_div = True   //满足条件</p><p><br/></p><p>        if tag == 'a' and self.in_div:</p><p>            self.in_a = True   //感兴趣的a的数据</p><p> <span class="Apple-tab-span" style="white-space:pre"> </span>self.current_pome[‘url’] = _attr(attrs,’href’)   //url的属性值</p><p><br/></p><p>    def handle_endtag(self, tag):   //当标志位结束的时候，我们要把这个标志位给它反制回来</p><p>        if tag == 'div':   //不是在div标签里面</p><p>            self.in_div = False</p><p><br/></p><p>        if tag == 'a':   //不是在a的标志位里面</p><p>            self.in_a = False</p><p><br/></p><p>    def handle_data(self, data):</p><p>        if self.in_a:   //当这个标志位在我们感兴趣的a的标志位里面时</p><p>            print(data)   //打印出这个数据，以便于后面的调试</p><p>            m = self.pattern.match(data)           </p><p>         if m:</p><p>                self.current_poem['title'] = m.group(1)   //标题</p><p>                self.current_poem['author'] = m.group(2)   //作者</p><p>                self.tangshi_list.append(self.current_poem)</p><p><br/></p><p>def retrive_tangshi_300():  //从以下网址去爬取唐诗三百首的数据</p><p>    url = 'http://www.gushiwen.org/gushi/tangshi.aspx'</p><p>    r = requests.get(url)   //获取到这个网页</p><p>    parser = PoemParser()</p><p>    parser.feed(r.content)   //解析数据</p><p>    return parser.tangshi_list   //将唐诗三百首列表返回</p><p> </p><p>if __name__ == '__main__':</p><p>    l = retrive_tangshi_300()  //调用这个唐诗三百首的函数，返回一个唐诗三百首的列表</p><p>    print('total %d poems.' % len(l))   //打印出我们爬取出了多少首唐诗</p><p>    for i in range(10):  </p><p>        print('标题: %(title)s\t作者：%(author)s\tURL: %(url)s' % (l[i]))  //打印出前十首诗词的标题，作者和url</p><p><br/></p><p>运行结果，先看我们打印的数据，这个数据是正确的。</p><p><br/></p><p><img alt="practice7.png" height="150" src="images/6fbddaa1fec815bfdb5f32a3c0b78f2d.png" style="width: 875px; height: 150px;" title="yqku0m1ZBHDVEJY0Cj.png" width="875"/></p><p><br/></p><p>我们再看打印的前十首古诗，这个是不正确的，因为我们把这个诗词单纯的加到列表里面，我们没有给它赋一个新的值，这样就导致，这样就导致，我们每次去修改的时候，都把最后一首诗加到里面，前面的都被覆盖掉，最后一首刚好就是塞下曲。</p><p><br/></p><p><img alt="practice8.png" src="images/8fca7ea52adf3e9fd9e95b648cee27d6.png" title="G9wickfAwhNV6Skfaw.png"/></p><p><br/></p><p>解决方法，修改代码：</p><p><br/></p><p># -*- coding: utf-8 -*-</p><p>import requests</p><p>import re</p><p>from HTMLParser import HTMLParser</p><p><br/></p><p><br/></p><p>def _attr(attrs, attrname):   //从属性列表里面去获取指定的值</p><p>    for attr in attrs:</p><p>        if attr[0] == attrname:</p><p>            return attr[1]</p><p>    return None</p><p><br/></p><p>class PoemParser(HTMLParser):</p><p>    def __init__(self):</p><p>        HTMLParser.__init__(self)</p><p>        self.in_div = False   //标志位是不是在这个div下面，默认是False </p><p>        self.in_a = False   //标志进去的是不是在感兴趣的a这个数据下</p><p>         //正则表达式的实例变量，正则表达式：标题部分是任意的字符，但必须有一个括号，compile方法一是为了提高可读性，而是为了提高这个运行的效率，因为handle_data会调用很多次，但实际上我们的正则表达式是一直不变的</p><p>        self.pattern = re.compile(r'''</p><p>(.+)    #匹配标题   group(1)</p><p>\(     #匹配作者左边的括号</p><p>(.+)    #匹配作者   group(2)</p><p>\)      #匹配作者右边的括号</p><p>‘’’,re.VERBOSE) </p><p>        self.tangshi_list = []   //解析出的唐诗三百首数据放在一个数组里</p><p>        self.current_poem = {}   //当前正在解析的唐诗</p><p><br/></p><p>    def handle_starttag(self, tag, attrs):</p><p>        if tag == 'div' and _attr(attrs, 'class') == 'guwencont2':  //需满足条件</p><p>            self.in_div = True   //满足条件</p><p><br/></p><p>        if tag == 'a' and self.in_div:</p><p>            self.in_a = True   //感兴趣的a的数据</p><p> <span class="Apple-tab-span" style="white-space:pre"> </span>self.current_pome[‘url’] = _attr(attrs,’href’)   //url的属性值</p><p><br/></p><p>    def handle_endtag(self, tag):   //当标志位结束的时候，我们要把这个标志位给它反制回来</p><p>        if tag == 'div':   //不是在div标签里面</p><p>            self.in_div = False</p><p><br/></p><p>        if tag == 'a':   //不是在a的标志位里面</p><p>            self.in_a = False</p><p><br/></p><p>    def handle_data(self, data):</p><p>        if self.in_a:   //当这个标志位在我们感兴趣的a的标志位里面时</p><p>            print(data)   //打印出这个数据，以便于后面的调试</p><p>            m = self.pattern.match(data)           </p><p>         if m:</p><p>                self.current_poem['title'] = m.group(1)   //标题</p><p>                self.current_poem['author'] = m.group(2)   //作者</p><p>                self.tangshi_list.append(self.current_poem)</p><p>self.current_poem = {}   //把当前的诗词保存起来以后，我们要给它赋一个新的空字典，这样我们前面的就不会被覆盖掉</p><p><br/></p><p>def retrive_tangshi_300():  //从以下网址去爬取唐诗三百首的数据</p><p>    url = 'http://www.gushiwen.org/gushi/tangshi.aspx'</p><p>    r = requests.get(url)   //获取到这个网页</p><p>    parser = PoemParser()</p><p>    parser.feed(r.content)   //解析数据</p><p>    return parser.tangshi_list   //将唐诗三百首列表返回</p><p> </p><p>if __name__ == '__main__':</p><p>    l = retrive_tangshi_300()  //调用这个唐诗三百首的函数，返回一个唐诗三百首的列表</p><p>    print('total %d poems.' % len(l))   //打印出我们爬取出了多少首唐诗</p><p>    for i in range(10):  </p><p>        print('标题: %(title)s\t作者：%(author)s\tURL: %(url)s' % (l[i]))  //打印出前十首诗词的标题，作者和url</p><p><br/></p><p>运行结果，最后的输出，这次是成功的。</p><p><br/></p><p><img alt="practice9.png" src="images/89773655a1c004b2f49f32dfb54bb7b4.png" title="9RelyhyfPy1bJAyEx4.png"/></p><p><br/></p><hr/><h3><span style="color: rgb(94, 207, 186);">作业：</span></h3><p><br/></p><p>宋词精选</p><p><br/></p><p><img alt="practice10.png" src="images/d26012e8545ee784783d71b17727996c.png" title="HUWTuW5EfNzVSMhAAu.png"/></p><p>1）词牌名</p><p><br/></p><p>2）标题</p><p><br/></p><p>3）作者</p><p><br/></p><p><br/></p><p><span style="color: rgb(192, 0, 0);">【本文由麦子学院独家原创，转载请注明出处并保留原文链接】</span></p><p><br/></p><p>
</p></p></div>
        </body></html>