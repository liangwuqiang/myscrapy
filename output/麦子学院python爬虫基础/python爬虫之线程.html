<!DOCTYPE html>
        <html><head><meta charset="UTF-8">
        </head><body>
        <p><center><h1>python爬虫之线程</h1></center></p>
            <div class="cont">
<h1>python爬虫之线程</h1>
<p><p></p><p></p><hr/><h3><span style="color: rgb(94, 207, 186);">认识线程</span></h3><p><span style="color: rgb(94, 207, 186);"><br/></span></p><p><strong>什么是线程？</strong></p><p><br/></p><p>1）并发执行的单元，可以同时执行多个任务，比如我们上次爬出来的唐诗是320首唐诗，我们是在循环里面一个一个去下载唐诗，那这个效率是比较低的，因为它是串行，下载完上一首才能下下一首，那我们采用多线程来实现的话，我们就可以同时实现多个唐诗。</p><p>2）从一个实例理解线程</p><p>3）线程带来的并发性</p><p><br/></p><p><strong>原子操作</strong></p><p><br/></p><p>1）什么是原子操作</p><p>2）为什么需要原子操作</p><p>3）怎么样保证原子操作</p><p><br/></p><p><strong>一个并发的例子</strong></p><p><strong><br/></strong></p><p>多线程执行</p><p>i=i+1</p><p>这行简单的代码实际上被分解成了下面三个操作</p><p><br/></p><p>操作分解：</p><p>1）CPU读取i的值</p><p>2）CPU执行+1的操作</p><p>3）CPU把结果写入i变量所在的内存</p><p>i=i+1这个赋值语句如果在单线程里面一点问题都没有，但是如果在多线程里面就会造成什么问题呢？假设在线程1里面读了一个i的值，执行完这个原子操作以后，被执行到2去，线程2也去读了这个i的值，这个时候，对线程1或者2来讲，假设这个i读出来都为0，接下来，线程1又被切换过来执行了，它去执行了+1操作，并且把它写到了i所在的内存里面去，那这个i的值就变成了1。那这个时候线程2也来执行了，它也执行的+1操作，因为它刚刚读的时候i的值是0，所以它加1以后也变成了1，这个时候它把1也写进去，所以最终i的值也是1，也就是说这个语句i=i+1被两个线程同时执行，那有可能这个i的值还是1，也就是它加了两次后还是1，其实我们的运行结果应该是2，这个就是线程并发造成的副作用。</p><p><br/></p><p>那怎么解决这个问题呢？也就是保证这是个原子操作，那怎么去实现这个功能呢？这个时候就要用到线程同步的一些机制了。</p><p><br/></p><p><strong>线程同步</strong></p><p><strong><br/></strong></p><p>管理关键资源的机制，确保并发的时候那个变量一定是正常的。</p><p><br/></p><p>例子：金库管理</p><p>1）采购需要进去拿钱去买东西</p><p>2）销售会把卖东西的钱放到金库里</p><p>3）进门需要一把很贵的纯金打造的感应钥匙</p><p><br/></p><p>1.锁：</p><p>1）aquire：上锁，获取金库钥匙</p><p>2）release：解锁，把钥匙放回</p><p>3）threading.Lock：钥匙带在进门的人身上，任何人要进来必须等里面的人出来了才可以。</p><p>4）threading.RLock：钥匙放在部门经理那，同一个部门里的人可以一起进来</p><p><br/></p><p>2.信号量：</p><p>1）threading.Semaphore：多配了几把钥匙，每个钥匙都带在进去的人身上</p><p>2）init_value：有多少把钥匙</p><p><br/></p><p>3.条件：</p><p>1）threading.Condition：金库里的钱花光了，采购拿到钥匙后，也拿不到钱。这个时候可以使用条件来实现，当销售部门卖完产品拿到钱后，会把钱放回金库，再通知采购去取钱。</p><p>2）wait，notify，notify_all  </p><p>Notify，通知一个排队的等，notify_all，通知所有的排队等</p><p>3）调用wait前需要获取资源锁aquire，先把这个锁锁住，才能看里面有没有钱，然后会自动把锁释放掉，释放完之后别人就可以进去了。</p><p><br/></p><p>4.事件：</p><p>1）和条件类似，不同的是不能像条件一样只通知一个人，条件可以通过notify通知最早排队的人，对于金库的例子，当销售把钱放回金库时，如果使用事件机制，那么所有排队的人都知道金库有钱了，他们都可以进去取。</p><p>2）另外一个不同点是事件没有锁机制，只是单纯在等待事件的发生，而条件是有锁机制的。</p><p><br/></p><p><br/></p><p><span style="color: rgb(192, 0, 0);">【本文由麦子学院独家原创，转载请注明出处并保留原文链接】</span></p><p><br/></p><p>
</p></p></div>
        </body></html>