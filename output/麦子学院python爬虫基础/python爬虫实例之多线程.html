<!DOCTYPE html>
        <html><head><meta charset="UTF-8">
        </head><body>
        <p><center><h1>python爬虫实例之多线程</h1></center></p>
            <div class="cont">
<h1>python爬虫实例之多线程</h1>
<p><p><br/></p><hr/><h3><span style="color: rgb(94, 207, 186);">这个线程数是不是越多越好呢？</span></h3><p><br/></p><p>总共我们有20张图片，那我们给它启动10个线程来看看结果。</p><p><br/></p><p># -*- coding: utf-8 -*-</p><p>import requests</p><p>import urllib</p><p>import os</p><p>import threading</p><p><br/></p><p>gImageList = []   //待下载的图片的url</p><p>gCondition = threading.Condition()   //线程间同步的地址</p><p><br/></p><p>class Producer(threading.Thread):   //定义一个生产者</p><p>def run(self):   //重载run函数</p><p>        global gImageList</p><p>        global gCondition</p><p><br/></p><p>        print('%s started' % threading.current_thread())   //获取尽量多的url，去把它放到列表里面</p><p>        imgs = download_wallpaper_list()   //获取图片的列表</p><p> </p><p>        gCondition.acquire()   //获取锁</p><p>        for img in imgs:</p><p>            if 'downloadUrl' in img:</p><p>                gImageList.append(img['downloadUrl'])   //把url放到列表里面去</p><p>        print('%s: produced %d urls. Left %d urls.' % (threading.current_thread(), len(gImageList)))   //打印出剩下多少图片</p><p>        gCondition.notify_all()   //通知消费者</p><p>        gCondition.release()  //释放锁</p><p><br/></p><p><br/></p><p>class Consumer(threading.Thread):   //定义一个消费者</p><p><br/></p><p>    def __init__(self, folder='wallpaper', group=None, target=None, name=None, args=(), kwargs=None, verbose=None):</p><p>        super(Consumer, self).__init__(group, target, name, args, kwargs, verbose)</p><p>        self.folder = folder</p><p><br/></p><p>    def run(self):   //重载run函数</p><p>        print('%s started' % threading.current_thread())</p><p>        while True:   //循环获取</p><p>            global gImageList</p><p>            global gCondition</p><p><br/></p><p>            gCondition.acquire()   //获取锁</p><p>            print('%s: trying to download image. Queue length is %d' % (threading.current_thread(), len(gImageList)))   //打印出当前线程名称和图片列表</p><p>            while len(gImageList) == 0:   //是否还有图片可下载</p><p>                gCondition.wait()   //没有就需要等待</p><p>                print('%s: waken up. Queue length is %d' % (threading.current_thread(), len(gImageList)))</p><p>            url = gImageList.pop()   //取出图片的url</p><p>            gCondition.release()  //释放锁，要在下载之前，因为我们用锁保护的这段代码里面应该尽量越少越好，才能更好的提高它的并发性</p><p><br/></p><p>            _download_image(url)   //下载图片</p><p><br/></p><p>def _download_image(url, folder=’image’):</p><p>    if not os.path.isdir(folder):</p><p>        os.mkdir(folder)</p><p>print('downloading %s' % url)</p><p><br/></p><p>def_(fname)s:</p><p>return os.path.join(folder,os.path.split(url) [1])</p><p>    urllib.urlretrieve(url, _filename(url))</p><p><br/></p><p>def download_wallpaper():</p><p>    # 数据分析</p><p>    # http://image.baidu.com/channel/wallpaper#%E7%83%AD%E9%97%A8%E6%8E%A8%E8%8D%90&amp;%E5%85%A8%E9%83%A8&amp;6&amp;0</p><p>    url = 'http://image.baidu.com/data/imgs'</p><p>    params = {</p><p>        'pn': 41,</p><p>        'rn': 100,</p><p>        'col': '壁纸',</p><p>        'tag': '国家地理',</p><p>        'tag3': '',</p><p>        'width': 1600,</p><p>        'height': 900,</p><p>        'ic': 0,</p><p>        'ie': 'utf8',</p><p>        'oe': 'utf-8',</p><p>        'image_id': '',</p><p>        'fr': 'channel',</p><p>        'p': 'channel',</p><p>        'from': 1,</p><p>        'app': 'img.browse.channel.wallpaper',</p><p>        't': '0.016929891658946872'</p><p>    }</p><p>    r = requests.get(url, params=params)</p><p>    imgs = r.json()['imgs']</p><p>print('%s:totally %d images' %(threading.current_thread(),len(imgs))  //打印出线程的名字</p><p>return imgs</p><p><br/></p><p>if __name__ == '__main__':</p><p>    Producer().start()   //创建一个生产者，让它启动</p><p><br/></p><p>    for i in range(10):</p><p>        Consumer().start()  //创建10个消费者</p><p><br/></p><p><br/></p><p><br/></p><p>运行结果，大家可以看到这个运行的就更快了。</p><p><br/></p><p><img alt="multithread1.png" src="images/6f6aba4b73f71dc6b49f03e6592cc09d.png" title="AR6voEuqXCFJS51vFY.png"/></p><p><br/></p><p>来看看下载的结果，这个图片又回来了。</p><p><br/></p><p><img alt="multithread2.png" src="images/6fc37f6b52174d71c7f58f928dc86fd8.png" title="JUZfaYijoXKdzIhIzl.png"/></p><p><br/></p><hr/><h3><span style="color: rgb(94, 207, 186);">多线程爬虫的问题</span></h3><p>Python多线程的限制条件：Python解析器的全局锁导致即使在多核CPU，一个时间片内也只能有一个Python程序在执行。所以即使你多线程，从微观的角度，CPU来看也是只有一个时间一个线程能运行，即使这个电脑是三核，四核都没有用。</p><p><br/></p><p>1）多线程只适用于有IO等待的场景，如果是有纯计算的场景，多线程无法优化性能</p><p>2）使用多进程multiprocessing（CPU的多核）</p><p>3）使用分布式（多台电脑上有多线程，这个时候我们运行可获取的线程就大大增加了）</p><p>4）关于并发有并发控制，关注twisted/gevent等基于事件的框架</p><p><br/></p><p><br/></p><p><br/></p><p><span style="color: rgb(192, 0, 0);">【本文由麦子学院独家原创，转载请注明出处并保留原文链接】</span></p><p><br/></p><p>
</p></p></div>
        </body></html>